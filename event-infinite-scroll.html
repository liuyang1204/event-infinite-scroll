<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-list/core-list.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../paper-shadow/paper-shadow.html">
<!--
Element providing infinite scroll to track the parentNode on reaching bottom and end.
It will raise event when it reaches. 
##### Example

    <event-infinite-scroll  on-reach-bottom="{{reachBottom}}" on-reach-top="{{reachTop}}"></event-infinite-scroll>

@element event-infinite-scroll
@blurb Element providing infinite scroll to track the parentNode on reaching bottom and end.
@status alpha
@homepage http://chadliu23.github.io/event-infinite-scroll
-->
<polymer-element name="event-infinite-scroll" extends="core-list"
                 attributes="up down">

    <template>
        <style>
            #upSpinner {
                top: -52px;
                -webkit-transition: top 0.3s linear;
            }

            #downSpinner {
                bottom: -52px;
            }

            .container {
                z-index: 1;
                position: absolute;
                border-radius: 50%;
                background-color: white;
                left: 50%;
                margin-left: -25px;
                right: 50%;
                width: 50px;
                height: 50px;
                -webkit-transition: bottom 0.3s linear;
            }
        </style>
        <div style="position: relative; overflow: hidden">
            <paper-shadow layered id="upSpinner" class="container" layout center-center horizontal
                          hidden?="{{!loadingUp}}">
                <paper-spinner active></paper-spinner>
            </paper-shadow>
            <shadow></shadow>
            <paper-shadow layered id="downSpinner" class="container" layout center-center horizontal>
                <paper-spinner active></paper-spinner>
            </paper-shadow>
        </div>
    </template>
    <script>
        Polymer('event-infinite-scroll', {

            animateScroll: function (scrollUp) {
                var self = this;
                requestAnimationFrame(step);
                var gap = scrollUp ? 5 : -5, times = 20;

                function step() {
                    setTimeout(function () {
                        if (times >= 0) {
                            requestAnimationFrame(step);
                            self.scrollTop = self.scrollTop - gap;
                            times--;
                        }
                    }, 10);
                }
            },
            up: false,
            down: false,
            loadingUp: false,
            loadingDown: false,
            minDelay: 1000,
            //Override to provide dynamic ajax loading
            endLoadingUp: function (items) {
                Array.prototype.unshift.apply(this.data, items);
                this.animateScroll(true);
                this.$.upSpinner.style.top = "-52px";
                this.loadingUp = false;
            },
            endLoadingDown: function (items) {
                Array.prototype.push.apply(this.data, items);
                this.animateScroll(false);
                this.$.downSpinner.style.bottom = "-52px";
                this.loadingDown = false;
            },
            scrollHandler: function () {
                var minDeplayed = false;
                var loadedItems = undefined;
                var scrollTop = this.getScrollTop(),
                        self = this;
                if (scrollTop === 0 && this.up && !this.loadingUp) {
                    this.loadingUp = true;
                    minDeplayed = false;
                    loadedItems = undefined;
                    setTimeout(function () {
                        minDeplayed = true;
                        if (loadedItems) {
                            self.endLoadingUp(loadedItems);
                        }
                    }, this.minDelay);
                    setTimeout(function () {
                        self.$.upSpinner.style.top = "8px";
                    }, 0);
                    this.fire('loading-up', {
                        callback: function (items) {
                            if (minDeplayed) {
                                self.endLoadingUp(items);
                            } else {
                                loadedItems = items;
                            }
                        }
                    });
                } else if ((scrollTop === this._target.scrollHeight - this._target.clientHeight) && this.down && !this.loadingDown) {
                    this.loadingDown = true;
                    minDeplayed = false;
                    loadedItems = undefined;
                    setTimeout(function () {
                        minDeplayed = true;
                        if (loadedItems) {
                            self.endLoadingDown(loadedItems);
                        }
                    }, this.minDelay);
                    setTimeout(function () {
                        self.$.downSpinner.style.bottom = "8px";
                    }, 100);
                    this.fire('loading-down', {
                        callback: function (items) {
                            if (minDeplayed) {
                                self.endLoadingDown(items);
                            } else {
                                loadedItems = items;
                            }
                        }
                    });
                }
                this.super();
            },

            // Override to solve the issue https://github.com/Polymer/core-list/issues/73
            _adjustVirtualIndex: function (splices, group) {
                if (this._targetSize === 0) {
                    return;
                }
                var totalDelta = 0;
                for (var i = 0; i < splices.length; i++) {
                    var s = splices[i];
                    var idx = s.index;
                    var gidx, gitem;
                    if (group) {
                        gidx = this.data.indexOf(group);
                        idx += this.virtualIndexForGroup(gidx);
                    }
                    // We only need to care about changes happening above the current position
                    if (idx > this._virtualStart) {
                        break;
                    }
                    var delta = Math.max(s.addedCount - s.removed.length, idx - this._virtualStart);
                    totalDelta += delta;
                    this._physicalStart += delta;
                    this._virtualStart += delta;
                    if (this._grouped) {
                        if (group) {
                            gitem = s.index;
                        } else {
                            var g = this.groupForVirtualIndex(s.index);
                            gidx = g.group;
                            gitem = g.groupIndex;
                        }
                        if (gidx == this._groupStart && gitem < this._groupStartIndex) {
                            this._groupStartIndex += delta;
                        }
                    }
                }
                // Adjust offset/scroll position based on total number of items changed
                if (this._virtualStart < this._physicalCount) {
                    this._resetIndex(this._getFirstVisibleIndex() || 0);
                } else {
                    totalDelta = Math.max((totalDelta / this._rowFactor) * this._physicalAverage, -this._physicalOffset);
                    this._physicalOffset += totalDelta;
                    this._scrollTop = this.setScrollTop(this._scrollTop + totalDelta);
                }
            }
        });
    </script>

</polymer-element>
