<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../paper-shadow/paper-shadow.html">
<!--
Element providing infinite scroll to track the parentNode on reaching bottom and end.
It will raise event when it reaches. 
##### Example

    <event-infinite-scroll  on-reach-bottom="{{reachBottom}}" on-reach-top="{{reachTop}}"></event-infinite-scroll>

@element event-infinite-scroll
@blurb Element providing infinite scroll to track the parentNode on reaching bottom and end.
@status alpha
@homepage http://chadliu23.github.io/event-infinite-scroll
-->
<polymer-element name="event-infinite-scroll"
                 attributes="up down data" vertical layout>

    <template>
        <style>
            :host {
                overflow: hidden;
            }
            #upSpinner {
                top: -52px;
                -webkit-transition: top 0.3s linear;
            }

            #downSpinner {
                bottom: -52px;
                -webkit-transition: bottom 0.3s linear;
            }

            .container {
                z-index: 1;
                position: absolute;
                border-radius: 50%;
                background-color: white;
                left: 50%;
                margin-left: -25px;
                width: 50px;
                height: 50px;
            }

            #scroller {
                overflow: auto;
            }
        </style>
        <paper-shadow layered id="upSpinner" class="container" layout center-center horizontal
                      hidden?="{{!loadingUp}}">
            <paper-spinner active></paper-spinner>
        </paper-shadow>
        <div on-scroll="{{scrollHandler}}" id="scroller" flex>
            <shadow></shadow>
        </div>
        <paper-shadow layered id="downSpinner" class="container" layout center-center horizontal
                      hidden?="{{!loadingDown}}">
            <paper-spinner active></paper-spinner>
        </paper-shadow>
    </template>
    <script>
        Polymer('event-infinite-scroll', {
            templateName: 'itemsTemplate',
            //Should be called immediately after the data changes.
            stayBottom: function () {
                var scroller = this.$.scroller;
                var gapBottom = scroller.scrollHeight - scroller.clientHeight - scroller.scrollTop;
                this.async(function () {
                    scroller.scrollTop = scroller.scrollHeight - scroller.clientHeight - gapBottom;
                });
            },
            scrollToBottom: function () {
                var scroller = this.$.scroller;
                this.async(function () {
                    scroller.scrollTop = scroller.scrollHeight - scroller.clientHeight;
                });
            },
            animateScroll: function (scrollUp) {
                var self = this.$.scroller;
                requestAnimationFrame(step);
                var gap = scrollUp ? 5 : -5, times = 20;

                function step() {
                    setTimeout(function () {
                        if (times >= 0) {
                            requestAnimationFrame(step);
                            self.scrollTop = self.scrollTop - gap;
                            times--;
                        }
                    }, 10);
                }
            },
            up: false,
            down: false,
            loadingUp: false,
            loadingDown: false,
            minDelay: 1000,
            //Override to provide dynamic ajax loading
            endLoadingUp: function (items) {
                var self = this;
                Array.prototype.unshift.apply(this.data, items);
                this.animateScroll(true);
                this.$.upSpinner.style.top = "-52px";
                this.loadingUp = false;
                this.async(function () {
                    var height = 0, children = self.children;
                    for (var i = 1; i <= items.length; i++) {
                        height += children[i].clientHeight;
                    }
                    this.$.scroller.scrollTop = height;
                });
            },
            endLoadingDown: function (items) {
                Array.prototype.push.apply(this.data, items);
                this.animateScroll(false);
                this.$.downSpinner.style.bottom = "-52px";
                this.loadingDown = false;
            },
            scrollHandler: function () {
                var minDeplayed = false;
                var loadedItems = undefined;
                var scrollTop = this.$.scroller.scrollTop;
                self = this;
                if (scrollTop === 0 && this.up && !this.loadingUp) {
                    this.loadingUp = true;
                    minDeplayed = false;
                    loadedItems = undefined;
                    setTimeout(function () {
                        minDeplayed = true;
                        if (loadedItems) {
                            self.endLoadingUp(loadedItems);
                        }
                    }, this.minDelay);
                    setTimeout(function () {
                        self.$.upSpinner.style.top = "8px";
                    }, 0);
                    this.fire('loading-up', {
                        callback: function (items) {
                            if (minDeplayed) {
                                self.endLoadingUp(items);
                            } else {
                                loadedItems = items;
                            }
                        }
                    });
                } else if ((scrollTop === this.$.scroller.scrollHeight - this.$.scroller.clientHeight) && this.down && !this.loadingDown) {
                    this.loadingDown = true;
                    minDeplayed = false;
                    loadedItems = undefined;
                    setTimeout(function () {
                        minDeplayed = true;
                        if (loadedItems) {
                            self.endLoadingDown(loadedItems);
                        }
                    }, this.minDelay);
                    setTimeout(function () {
                        self.$.downSpinner.style.bottom = "8px";
                    }, 0);
                    this.fire('loading-down', {
                        callback: function (items) {
                            if (minDeplayed) {
                                self.endLoadingDown(items);
                            } else {
                                loadedItems = items;
                            }
                        }
                    });
                }
            }
        });
    </script>

</polymer-element>
